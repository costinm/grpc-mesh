{
  "swagger": "2.0",
  "info": {
    "title": "istio/networking/v1/sidecar.proto",
    "description": "`Sidecar` describes the configuration of the sidecar proxy that mediates\ninbound and outbound communication to the workload instance it is attached to. By\ndefault, Istio will program all sidecar proxies in the mesh with the\nnecessary configuration required to reach every workload instance in the mesh, as\nwell as accept traffic on all the ports associated with the\nworkload. The `Sidecar` configuration provides a way to fine tune the set of\nports, protocols that the proxy will accept when forwarding traffic to\nand from the workload. In addition, it is possible to restrict the set\nof services that the proxy can reach when forwarding outbound traffic\nfrom workload instances.\n\nServices and configuration in a mesh are organized into one or more\nnamespaces (e.g., a Kubernetes namespace or a CF org/space). A `Sidecar`\nconfiguration in a namespace will apply to one or more workload instances in the same\nnamespace, selected using the `workloadSelector` field. In the absence of a\n`workloadSelector`, it will apply to all workload instances in the same\nnamespace. When determining the `Sidecar` configuration to be applied to a\nworkload instance, preference will be given to the resource with a\n`workloadSelector` that selects this workload instance, over a `Sidecar` configuration\nwithout any `workloadSelector`.\n\n**NOTE 1**: *_Each namespace can have only one `Sidecar`\nconfiguration without any `workloadSelector`_ that specifies the\ndefault for all pods in that namespace*. It is recommended to use\nthe name `default` for the namespace-wide sidecar. The behavior of\nthe system is undefined if more than one selector-less `Sidecar`\nconfigurations exist in a given namespace. The behavior of the\nsystem is undefined if two or more `Sidecar` configurations with a\n`workloadSelector` select the same workload instance.\n\n**NOTE 2**: *_A `Sidecar` configuration in the `MeshConfig`\n[root namespace](https://istio.io/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig)\nwill be applied by default to all namespaces without a `Sidecar`\nconfiguration_*. This global default `Sidecar` configuration should not have\nany `workloadSelector`.\n\nThe example below declares a global default `Sidecar` configuration\nin the root namespace called `istio-config`, that configures\nsidecars in all namespaces to allow egress traffic only to other\nworkloads in the same namespace as well as to services in the\n`istio-system` namespace.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: Sidecar\nmetadata:\n  name: default\n  namespace: istio-config\nspec:\n  egress:\n  - hosts:\n    - \"./*\"\n    - \"istio-system/*\"\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: Sidecar\nmetadata:\n  name: default\n  namespace: istio-config\nspec:\n  egress:\n  - hosts:\n    - \"./*\"\n    - \"istio-system/*\"\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nThe example below declares a `Sidecar` configuration in the\n`prod-us1` namespace that overrides the global default defined\nabove, and configures the sidecars in the namespace to allow egress\ntraffic to public services in the `prod-us1`, `prod-apis`, and the\n`istio-system` namespaces.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: Sidecar\nmetadata:\n  name: default\n  namespace: prod-us1\nspec:\n  egress:\n  - hosts:\n    - \"prod-us1/*\"\n    - \"prod-apis/*\"\n    - \"istio-system/*\"\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: Sidecar\nmetadata:\n  name: default\n  namespace: prod-us1\nspec:\n  egress:\n  - hosts:\n    - \"prod-us1/*\"\n    - \"prod-apis/*\"\n    - \"istio-system/*\"\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nThe following example declares a `Sidecar` configuration in the\n`prod-us1` namespace for all pods with labels `app: ratings`\nbelonging to the `ratings.prod-us1` service.  The workload accepts\ninbound HTTP traffic on port 9080. The traffic is then forwarded to\nthe attached workload instance listening on a Unix domain\nsocket. In the egress direction, in addition to the `istio-system`\nnamespace, the sidecar proxies only HTTP traffic bound for port\n9080 for services in the `prod-us1` namespace.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: Sidecar\nmetadata:\n  name: ratings\n  namespace: prod-us1\nspec:\n  workloadSelector:\n    labels:\n      app: ratings\n  ingress:\n  - port:\n      number: 9080\n      protocol: HTTP\n      name: somename\n    defaultEndpoint: unix:///var/run/someuds.sock\n  egress:\n  - port:\n      number: 9080\n      protocol: HTTP\n      name: egresshttp\n    hosts:\n    - \"prod-us1/*\"\n  - hosts:\n    - \"istio-system/*\"\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: Sidecar\nmetadata:\n  name: ratings\n  namespace: prod-us1\nspec:\n  workloadSelector:\n    labels:\n      app: ratings\n  ingress:\n  - port:\n      number: 9080\n      protocol: HTTP\n      name: somename\n    defaultEndpoint: unix:///var/run/someuds.sock\n  egress:\n  - port:\n      number: 9080\n      protocol: HTTP\n      name: egresshttp\n    hosts:\n    - \"prod-us1/*\"\n  - hosts:\n    - \"istio-system/*\"\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nIf the workload is deployed without IPTables-based traffic capture,\nthe `Sidecar` configuration is the only way to configure the ports\non the proxy attached to the workload instance. The following\nexample declares a `Sidecar` configuration in the `prod-us1`\nnamespace for all pods with labels `app: productpage` belonging to\nthe `productpage.prod-us1` service. Assuming that these pods are\ndeployed without IPtable rules (i.e. the `istio-init` container)\nand the proxy metadata `ISTIO_META_INTERCEPTION_MODE` is set to\n`NONE`, the specification, below, allows such pods to receive HTTP\ntraffic on port 9080 (wrapped inside Istio mutual TLS) and forward\nit to the application listening on `127.0.0.1:8080`. It also allows\nthe application to communicate with a backing MySQL database on\n`127.0.0.1:3306`, that then gets proxied to the externally hosted\nMySQL service at `mysql.foo.com:3306`.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: Sidecar\nmetadata:\n  name: no-ip-tables\n  namespace: prod-us1\nspec:\n  workloadSelector:\n    labels:\n      app: productpage\n  ingress:\n  - port:\n      number: 9080 # binds to proxy_instance_ip:9080 (0.0.0.0:9080, if no unicast IP is available for the instance)\n      protocol: HTTP\n      name: somename\n    defaultEndpoint: 127.0.0.1:8080\n    captureMode: NONE # not needed if metadata is set for entire proxy\n  egress:\n  - port:\n      number: 3306\n      protocol: MYSQL\n      name: egressmysql\n    captureMode: NONE # not needed if metadata is set for entire proxy\n    bind: 127.0.0.1\n    hosts:\n    - \"*/mysql.foo.com\"\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: Sidecar\nmetadata:\n  name: no-ip-tables\n  namespace: prod-us1\nspec:\n  workloadSelector:\n    labels:\n      app: productpage\n  ingress:\n  - port:\n      number: 9080 # binds to proxy_instance_ip:9080 (0.0.0.0:9080, if no unicast IP is available for the instance)\n      protocol: HTTP\n      name: somename\n    defaultEndpoint: 127.0.0.1:8080\n    captureMode: NONE # not needed if metadata is set for entire proxy\n  egress:\n  - port:\n      number: 3306\n      protocol: MYSQL\n      name: egressmysql\n    captureMode: NONE # not needed if metadata is set for entire proxy\n    bind: 127.0.0.1\n    hosts:\n    - \"*/mysql.foo.com\"\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nAnd the associated service entry for routing to `mysql.foo.com:3306`\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: external-svc-mysql\n  namespace: ns1\nspec:\n  hosts:\n  - mysql.foo.com\n  ports:\n  - number: 3306\n    name: mysql\n    protocol: MYSQL\n  location: MESH_EXTERNAL\n  resolution: DNS\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: ServiceEntry\nmetadata:\n  name: external-svc-mysql\n  namespace: ns1\nspec:\n  hosts:\n  - mysql.foo.com\n  ports:\n  - number: 3306\n    name: mysql\n    protocol: MYSQL\n  location: MESH_EXTERNAL\n  resolution: DNS\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nIt is also possible to mix and match traffic capture modes in a single\nproxy. For example, consider a setup where internal services are on the\n`192.168.0.0/16` subnet. So, IP tables are setup on the VM to capture all\noutbound traffic on `192.168.0.0/16` subnet. Assume that the VM has an\nadditional network interface on `172.16.0.0/16` subnet for inbound\ntraffic. The following `Sidecar` configuration allows the VM to expose a\nlistener on `172.16.1.32:80` (the VM's IP) for traffic arriving from the\n`172.16.0.0/16` subnet.\n\n**NOTE**: The `ISTIO_META_INTERCEPTION_MODE` metadata on the\nproxy in the VM should contain `REDIRECT` or `TPROXY` as its value,\nimplying that IP tables based traffic capture is active.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: Sidecar\nmetadata:\n  name: partial-ip-tables\n  namespace: prod-us1\nspec:\n  workloadSelector:\n    labels:\n      app: productpage\n  ingress:\n  - bind: 172.16.1.32\n    port:\n      number: 80 # binds to 172.16.1.32:80\n      protocol: HTTP\n      name: somename\n    defaultEndpoint: 127.0.0.1:8080\n    captureMode: NONE\n  egress:\n    # use the system detected defaults\n    # sets up configuration to handle outbound traffic to services\n    # in 192.168.0.0/16 subnet, based on information provided by the\n    # service registry\n  - captureMode: IPTABLES\n    hosts:\n    - \"*/*\"\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: Sidecar\nmetadata:\n  name: partial-ip-tables\n  namespace: prod-us1\nspec:\n  workloadSelector:\n    labels:\n      app: productpage\n  ingress:\n  - bind: 172.16.1.32\n    port:\n      number: 80 # binds to 172.16.1.32:80\n      protocol: HTTP\n      name: somename\n    defaultEndpoint: 127.0.0.1:8080\n    captureMode: NONE\n  egress:\n    # use the system detected defaults\n    # sets up configuration to handle outbound traffic to services\n    # in 192.168.0.0/16 subnet, based on information provided by the\n    # service registry\n  - captureMode: IPTABLES\n    hosts:\n    - \"*/*\"\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}",
    "version": "version not set"
  },
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {},
  "definitions": {
    "googleprotobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "googlerpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32",
          "description": "The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code]."
        },
        "message": {
          "type": "string",
          "description": "A developer-facing error message, which should be in English. Any\nuser-facing error message should be localized and sent in the\n[google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client."
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/googleprotobufAny"
          },
          "description": "A list of messages that carry the error details.  There is a common set of\nmessage types for APIs to use."
        }
      },
      "description": "The `Status` type defines a logical error model that is suitable for\ndifferent programming environments, including REST APIs and RPC APIs. It is\nused by [gRPC](https://github.com/grpc). Each `Status` message contains\nthree pieces of data: error code, error message, and error details.\n\nYou can find out more about this error model and how to work with it in the\n[API Design Guide](https://cloud.google.com/apis/design/errors)."
    }
  }
}
