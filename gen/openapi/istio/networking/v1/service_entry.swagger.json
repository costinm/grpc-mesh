{
  "swagger": "2.0",
  "info": {
    "title": "istio/networking/v1/service_entry.proto",
    "description": "`ServiceEntry` enables adding additional entries into Istio's\ninternal service registry, so that auto-discovered services in the\nmesh can access/route to these manually specified services. A\nservice entry describes the properties of a service (DNS name,\nVIPs, ports, protocols, endpoints). These services could be\nexternal to the mesh (e.g., web APIs) or mesh-internal services\nthat are not part of the platform's service registry (e.g., a set\nof VMs talking to services in Kubernetes). In addition, the\nendpoints of a service entry can also be dynamically selected by\nusing the `workloadSelector` field. These endpoints can be VM\nworkloads declared using the `WorkloadEntry` object or Kubernetes\npods. The ability to select both pods and VMs under a single\nservice allows for migration of services from VMs to Kubernetes\nwithout having to change the existing DNS names associated with the\nservices.\n\nThe following example declares a few external APIs accessed by internal\napplications over HTTPS. The sidecar inspects the SNI value in the\nClientHello message to route to the appropriate external service.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: external-svc-https\nspec:\n  hosts:\n  - api.dropboxapi.com\n  - www.googleapis.com\n  - api.facebook.com\n  location: MESH_EXTERNAL\n  ports:\n  - number: 443\n    name: https\n    protocol: TLS\n  resolution: DNS\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: ServiceEntry\nmetadata:\n  name: external-svc-https\nspec:\n  hosts:\n  - api.dropboxapi.com\n  - www.googleapis.com\n  - api.facebook.com\n  location: MESH_EXTERNAL\n  ports:\n  - number: 443\n    name: https\n    protocol: TLS\n  resolution: DNS\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nThe following configuration adds a set of MongoDB instances running on\nunmanaged VMs to Istio's registry, so that these services can be treated\nas any other service in the mesh. The associated DestinationRule is used\nto initiate mTLS connections to the database instances.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: external-svc-mongocluster\nspec:\n  hosts:\n  - mymongodb.somedomain # not used\n  addresses:\n  - 192.192.192.192/24 # VIPs\n  ports:\n  - number: 27018\n    name: mongodb\n    protocol: MONGO\n  location: MESH_INTERNAL\n  resolution: STATIC\n  endpoints:\n  - address: 2.2.2.2\n  - address: 3.3.3.3\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: ServiceEntry\nmetadata:\n  name: external-svc-mongocluster\nspec:\n  hosts:\n  - mymongodb.somedomain # not used\n  addresses:\n  - 192.192.192.192/24 # VIPs\n  ports:\n  - number: 27018\n    name: mongodb\n    protocol: MONGO\n  location: MESH_INTERNAL\n  resolution: STATIC\n  endpoints:\n  - address: 2.2.2.2\n  - address: 3.3.3.3\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nand the associated DestinationRule\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: DestinationRule\nmetadata:\n  name: mtls-mongocluster\nspec:\n  host: mymongodb.somedomain\n  trafficPolicy:\n    tls:\n      mode: MUTUAL\n      clientCertificate: /etc/certs/myclientcert.pem\n      privateKey: /etc/certs/client_private_key.pem\n      caCertificates: /etc/certs/rootcacerts.pem\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: DestinationRule\nmetadata:\n  name: mtls-mongocluster\nspec:\n  host: mymongodb.somedomain\n  trafficPolicy:\n    tls:\n      mode: MUTUAL\n      clientCertificate: /etc/certs/myclientcert.pem\n      privateKey: /etc/certs/client_private_key.pem\n      caCertificates: /etc/certs/rootcacerts.pem\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nThe following example uses a combination of service entry and TLS\nrouting in a virtual service to steer traffic based on the SNI value to\nan internal egress firewall.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: external-svc-redirect\nspec:\n  hosts:\n  - wikipedia.org\n  - \"*.wikipedia.org\"\n  location: MESH_EXTERNAL\n  ports:\n  - number: 443\n    name: https\n    protocol: TLS\n  resolution: NONE\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: ServiceEntry\nmetadata:\n  name: external-svc-redirect\nspec:\n  hosts:\n  - wikipedia.org\n  - \"*.wikipedia.org\"\n  location: MESH_EXTERNAL\n  ports:\n  - number: 443\n    name: https\n    protocol: TLS\n  resolution: NONE\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nAnd the associated VirtualService to route based on the SNI value.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: tls-routing\nspec:\n  hosts:\n  - wikipedia.org\n  - \"*.wikipedia.org\"\n  tls:\n  - match:\n    - sniHosts:\n      - wikipedia.org\n      - \"*.wikipedia.org\"\n    route:\n    - destination:\n        host: internal-egress-firewall.ns1.svc.cluster.local\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: tls-routing\nspec:\n  hosts:\n  - wikipedia.org\n  - \"*.wikipedia.org\"\n  tls:\n  - match:\n    - sniHosts:\n      - wikipedia.org\n      - \"*.wikipedia.org\"\n    route:\n    - destination:\n        host: internal-egress-firewall.ns1.svc.cluster.local\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nThe virtual service with TLS match serves to override the default SNI\nmatch. In the absence of a virtual service, traffic will be forwarded to\nthe wikipedia domains.\n\nThe following example demonstrates the use of a dedicated egress gateway\nthrough which all external service traffic is forwarded.\nThe 'exportTo' field allows for control over the visibility of a service\ndeclaration to other namespaces in the mesh. By default, a service is exported\nto all namespaces. The following example restricts the visibility to the\ncurrent namespace, represented by \".\", so that it cannot be used by other\nnamespaces.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: external-svc-httpbin\n  namespace : egress\nspec:\n  hosts:\n  - example.com\n  exportTo:\n  - \".\"\n  location: MESH_EXTERNAL\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n  resolution: DNS\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: ServiceEntry\nmetadata:\n  name: external-svc-httpbin\n  namespace : egress\nspec:\n  hosts:\n  - example.com\n  exportTo:\n  - \".\"\n  location: MESH_EXTERNAL\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n  resolution: DNS\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nDefine a gateway to handle all egress traffic.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: Gateway\nmetadata:\n name: istio-egressgateway\n namespace: istio-system\nspec:\n selector:\n   istio: egressgateway\n servers:\n - port:\n     number: 80\n     name: http\n     protocol: HTTP\n   hosts:\n   - \"*\"\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: Gateway\nmetadata:\n name: istio-egressgateway\n namespace: istio-system\nspec:\n selector:\n   istio: egressgateway\n servers:\n - port:\n     number: 80\n     name: http\n     protocol: HTTP\n   hosts:\n   - \"*\"\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nAnd the associated `VirtualService` to route from the sidecar to the\ngateway service (`istio-egressgateway.istio-system.svc.cluster.local`), as\nwell as route from the gateway to the external service. Note that the\nvirtual service is exported to all namespaces enabling them to route traffic\nthrough the gateway to the external service. Forcing traffic to go through\na managed middle proxy like this is a common practice.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: gateway-routing\n  namespace: egress\nspec:\n  hosts:\n  - example.com\n  exportTo:\n  - \"*\"\n  gateways:\n  - mesh\n  - istio-egressgateway\n  http:\n  - match:\n    - port: 80\n      gateways:\n      - mesh\n    route:\n    - destination:\n        host: istio-egressgateway.istio-system.svc.cluster.local\n  - match:\n    - port: 80\n      gateways:\n      - istio-egressgateway\n    route:\n    - destination:\n        host: example.com\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: gateway-routing\n  namespace: egress\nspec:\n  hosts:\n  - example.com\n  exportTo:\n  - \"*\"\n  gateways:\n  - mesh\n  - istio-egressgateway\n  http:\n  - match:\n    - port: 80\n      gateways:\n      - mesh\n    route:\n    - destination:\n        host: istio-egressgateway.istio-system.svc.cluster.local\n  - match:\n    - port: 80\n      gateways:\n      - istio-egressgateway\n    route:\n    - destination:\n        host: example.com\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nThe following example demonstrates the use of wildcards in the hosts for\nexternal services. If the connection has to be routed to the IP address\nrequested by the application (i.e. application resolves DNS and attempts\nto connect to a specific IP), the discovery mode must be set to `NONE`.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: external-svc-wildcard-example\nspec:\n  hosts:\n  - \"*.bar.com\"\n  location: MESH_EXTERNAL\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n  resolution: NONE\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: ServiceEntry\nmetadata:\n  name: external-svc-wildcard-example\nspec:\n  hosts:\n  - \"*.bar.com\"\n  location: MESH_EXTERNAL\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n  resolution: NONE\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nThe following example demonstrates a service that is available via a\nUnix Domain Socket on the host of the client. The resolution must be\nset to STATIC to use Unix address endpoints.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: unix-domain-socket-example\nspec:\n  hosts:\n  - \"example.unix.local\"\n  location: MESH_EXTERNAL\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n  resolution: STATIC\n  endpoints:\n  - address: unix:///var/run/example/socket\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: ServiceEntry\nmetadata:\n  name: unix-domain-socket-example\nspec:\n  hosts:\n  - \"example.unix.local\"\n  location: MESH_EXTERNAL\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n  resolution: STATIC\n  endpoints:\n  - address: unix:///var/run/example/socket\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nFor HTTP-based services, it is possible to create a `VirtualService`\nbacked by multiple DNS addressable endpoints. In such a scenario, the\napplication can use the `HTTP_PROXY` environment variable to transparently\nreroute API calls for the `VirtualService` to a chosen backend. For\nexample, the following configuration creates a non-existent external\nservice called foo.bar.com backed by three domains: us.foo.bar.com:8080,\nuk.foo.bar.com:9080, and in.foo.bar.com:7080\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: external-svc-dns\nspec:\n  hosts:\n  - foo.bar.com\n  location: MESH_EXTERNAL\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n  resolution: DNS\n  endpoints:\n  - address: us.foo.bar.com\n    ports:\n      http: 8080\n  - address: uk.foo.bar.com\n    ports:\n      http: 9080\n  - address: in.foo.bar.com\n    ports:\n      http: 7080\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: ServiceEntry\nmetadata:\n  name: external-svc-dns\nspec:\n  hosts:\n  - foo.bar.com\n  location: MESH_EXTERNAL\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n  resolution: DNS\n  endpoints:\n  - address: us.foo.bar.com\n    ports:\n      http: 8080\n  - address: uk.foo.bar.com\n    ports:\n      http: 9080\n  - address: in.foo.bar.com\n    ports:\n      http: 7080\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nWith `HTTP_PROXY=http://localhost/`, calls from the application to\n`http://foo.bar.com` will be load balanced across the three domains\nspecified above. In other words, a call to `http://foo.bar.com/baz` would\nbe translated to `http://uk.foo.bar.com/baz`.\n\nThe following example illustrates the usage of a `ServiceEntry`\ncontaining a subject alternate name\nwhose format conforms to the [SPIFFE standard](https://github.com/spiffe/spiffe/blob/master/standards/SPIFFE-ID.md):\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: httpbin\n  namespace : httpbin-ns\nspec:\n  hosts:\n  - example.com\n  location: MESH_INTERNAL\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n  resolution: STATIC\n  endpoints:\n  - address: 2.2.2.2\n  - address: 3.3.3.3\n  subjectAltNames:\n  - \"spiffe://cluster.local/ns/httpbin-ns/sa/httpbin-service-account\"\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: ServiceEntry\nmetadata:\n  name: httpbin\n  namespace : httpbin-ns\nspec:\n  hosts:\n  - example.com\n  location: MESH_INTERNAL\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n  resolution: STATIC\n  endpoints:\n  - address: 2.2.2.2\n  - address: 3.3.3.3\n  subjectAltNames:\n  - \"spiffe://cluster.local/ns/httpbin-ns/sa/httpbin-service-account\"\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nThe following example demonstrates the use of `ServiceEntry` with a\n`workloadSelector` to handle the migration of a service\n`details.bookinfo.com` from VMs to Kubernetes. The service has two\nVM-based instances with sidecars as well as a set of Kubernetes\npods managed by a standard deployment object. Consumers of this\nservice in the mesh will be automatically load balanced across the\nVMs and Kubernetes.  VM for the `details.bookinfo.com`\nservice. This VM has sidecar installed and bootstrapped using the\n`details-legacy` service account. The sidecar receives HTTP traffic\non port 80 (wrapped in istio mutual TLS) and forwards it to the\napplication on the localhost on the same port.\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: WorkloadEntry\nmetadata:\n  name: details-vm-1\nspec:\n  serviceAccount: details\n  address: 2.2.2.2\n  labels:\n    app: details\n    instance-id: vm1\n---\napiVersion: networking.istio.io/v1alpha3\nkind: WorkloadEntry\nmetadata:\n  name: details-vm-2\nspec:\n  serviceAccount: details\n  address: 3.3.3.3\n  labels:\n    app: details\n    instance-id: vm2\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: WorkloadEntry\nmetadata:\n  name: details-vm-1\nspec:\n  serviceAccount: details\n  address: 2.2.2.2\n  labels:\n    app: details\n    instance-id: vm1\n---\napiVersion: networking.istio.io/v1beta1\nkind: WorkloadEntry\nmetadata:\n  name: details-vm-2\nspec:\n  serviceAccount: details\n  address: 3.3.3.3\n  labels:\n    app: details\n    instance-id: vm2\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}\n\nAssuming there is also a Kubernetes deployment with pod labels\n`app: details` using the same service account `details`, the\nfollowing service entry declares a service spanning both VMs and\nKubernetes:\n\n{{\u003ctabset category-name=\"example\"\u003e}}\n{{\u003ctab name=\"v1alpha3\" category-value=\"v1alpha3\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: ServiceEntry\nmetadata:\n  name: details-svc\nspec:\n  hosts:\n  - details.bookinfo.com\n  location: MESH_INTERNAL\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n  resolution: STATIC\n  workloadSelector:\n    labels:\n      app: details\n```\n{{\u003c/tab\u003e}}\n\n{{\u003ctab name=\"v1beta1\" category-value=\"v1beta1\"\u003e}}\n```yaml\napiVersion: networking.istio.io/v1beta1\nkind: ServiceEntry\nmetadata:\n  name: details-svc\nspec:\n  hosts:\n  - details.bookinfo.com\n  location: MESH_INTERNAL\n  ports:\n  - number: 80\n    name: http\n    protocol: HTTP\n  resolution: STATIC\n  workloadSelector:\n    labels:\n      app: details\n```\n{{\u003c/tab\u003e}}\n{{\u003c/tabset\u003e}}",
    "version": "version not set"
  },
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {},
  "definitions": {
    "googleprotobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "googlerpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32",
          "description": "The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code]."
        },
        "message": {
          "type": "string",
          "description": "A developer-facing error message, which should be in English. Any\nuser-facing error message should be localized and sent in the\n[google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client."
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/googleprotobufAny"
          },
          "description": "A list of messages that carry the error details.  There is a common set of\nmessage types for APIs to use."
        }
      },
      "description": "The `Status` type defines a logical error model that is suitable for\ndifferent programming environments, including REST APIs and RPC APIs. It is\nused by [gRPC](https://github.com/grpc). Each `Status` message contains\nthree pieces of data: error code, error message, and error details.\n\nYou can find out more about this error model and how to work with it in the\n[API Design Guide](https://cloud.google.com/apis/design/errors)."
    }
  }
}
